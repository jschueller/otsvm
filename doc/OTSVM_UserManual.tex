% 
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.2
% or any later version published by the Free Software Foundation;
% with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
% Texts.  A copy of the license is included in the section entitled "GNU
% Free Documentation License".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{User Manual}

This section gives an exhaustive presentation of the objects and functions provided by the $otsvm$ module, in the alphabetic order.


\subsection{LibSVMRegression}

A $LibSVMRegression$ is an $otsvm$ object.

\begin{description}
 \item [Usage :] \strut
  \begin{description}
    \item $LibSVMRegression( dataIn, dataOut, kerneltype )$
    \item $LibSVMRegression( inputFunction, experience, kerneltype )$
    \item $LibSVMRegression( dataIn, dataOut, distribution, kerneltype )$
  \end{description}

 \item[Arguments :] \strut
  \begin{description}
   \item $dataIn$ : a NumericalSample, an OpenTURNS object which is the input sample.
   \item $dataOut$ : a NumericalSample, an OpenTURNS object which is the output sample.
   \item $kerneltype$ : a Libsvm enum which is the selection of the kernel. We can select (Linear, Polynomial, NormalRbf, Sigmoid).
   \item $experience$ : an Experiment, an OpenTURNS object which is an experiment plane.
   \item $distribution$ : a Distribution, an OpenTURNS object which is the isoprobalistic distribution 
  \end{description}

 \item[Value : ] a LibSVMRegression which is the object manipulated to make the regression.

 \item[Some methods :] \strut
  \begin{description}
   \item $run$
    \begin{description}
     \item [Usage :] $run()$
     \item [Argument :] none.
     \item [Value :] none. It makes the svm regression and builds the metamodel. To understand the algorithm, First, we make a cross validation to determinate the best parameters. Second, we train the problem and retreive some results ( support vectors, support vectors coefficients, kernel parameters). Third, we build the model with OpenTurns and save results in the MetaModelResult.
    \end{description}

  \end{description}


  
\end{description}

\newpage \subsection{LibSVMClassification}

A $LibSVMClassification$ is an $otsvm$ object.

\begin{description}
 \item [Usage :] \strut
  \begin{description}
    \item $LibSVMClassification( dataIn, outClasses )$
  \end{description}

 \item[Arguments :] \strut
  \begin{description}
   \item $dataIn$ : a NumericalSample, an OpenTURNS object which is the input sample.
   \item $outClasses$ : an Indices, an OpenTURNS object which is the output labels ( labels must be positive ).
  \end{description}

 \item[Value : ] a LibSVMClassification which is the object manipulated to make the classification.

 \item[Some methods :] \strut
  \begin{description}
   \item $run$
    \begin{description}
     \item [Usage :] $run()$
     \item [Argument :] none.
     \item [Value :] none. It makes the svm classification and builds the metamodel.
    \end{description}
   \item $classify$
    \begin{description}
     \item [Usage :] \strut
	\begin{description}
	 \item $getLabel(vector)$
	 \item $getLabel(sample)$
	\end{description}	
     \item [Argument :] \strut
	  \begin{description}
	   \item $vector$, an OpenTURNS object which is a NumericalPoint. This is the input vector to classify.
	   \item $sample$, an OpenTURNS object which is a NumericalSample. This is an input sample to classify.
	  \end{description}
     \item [Value :] \strut
      \begin{description}
       \item an UnsignedLong for the vector, an openturns type. It predicts for an input vector , the output label. 
       \item a Indices for the sample, an openturns object. It predicts for a sample, the output label for each vector.
      \end{description}
    \end{description}

  \item $setKernelType$
    \begin{description}
     \item [Usage :] $setKernelType( kerneltype )$
     \item [Argument :] $kerneltype$: an enum from LibSVM. We can select (Linear, Polynomial, NormalRbf, Sigmoid).
     \item [Value :] none. It set the type of the kernel.
    \end{description}

  \item $setTradeoffFactor$
    \begin{description}
     \item [Usage :] $setTradeoffFactor( trade )$
     \item [Argument :] $trade$ : a NumericalPoint, an OpenTURNS object.
     \item [Value :] none. It set the tradeoff factor.
    \end{description}

  \item $setKernelParameter$
    \begin{description}
     \item [Usage :] $setKernelParameter( kernel )$
     \item [Argument :] $kernel$ : a NumericalPoint, an OpenTURNS object.
     \item [Value :] none. It set the kernel parameter.
    \end{description}
  \newpage
   \item $grade$
    \begin{description}
     \item [Usage :] \strut
      \begin{description}
       \item $grade(vector, outClasse)$
       \item $grade(sample, indices)$
      \end{description}
     \item [Argument :] \strut
	 \begin{description}
	  \item $vector$, an OpenTURNS object which is a NumericalPoint. This is the input vector.
	  \item $sample$, an OpenTURNS object which is a NumericalSample. This is the input sample.
	  \item $outClasse$, an UnsignedLong, an OpenTURNS type. This is a potential label.
	  \item $indices$, a Indices, an OpenTURNS object. This is a list of potentials labels.
	 \end{description}
     \item [Value :] \strut
      \begin{description}
       \item an UnsignedLong for the vector, an openturns type. It gives a positive integer. More the value is high and more the given label in parameter is a good label for the vector. The maximum of this value is number of classes - 1. 
       \item a Indices for the sample, an openturns object. It gives a list of positives integers. More the value is high and more the given label in parameter is a good label for each vector. The maximum of this value is number of classes - 1. 
      \end{description}
  \item $setWeight$
    \begin{description}
     \item [Usage :] $setWeight( weigt )$
     \item [Argument :] $weight$ : a NumericalPoint, an OpenTURNS object.
     \item [Value :] none. For each class, we associate a penalty. It is useful for unbalances data or assymetric misclassification cost.
    \end{description}



    \end{description}


    

  \end{description}
\end{description}

\newpage \subsection{Various}

The module adds some keys to the $ResourceMap$ in OpenTURNS.\\

There is five new keys :
\begin{itemize}
 \item $LibSVM-DegreePolynomialKernel$ : the degree of the polynomial kernel $d$. By default, it's 3.
 \item $LibSVM-ConstantPolynomialKernel$ : the constant of the polynomial kernel $c$. By default it's 0.
 \item $LibSVM-CacheSize$ : the cache size of the calculation for kernel trick in MB. By default, it's 100.
 \item $LibSVM-Epsilon$ : the parameter $\varepsilon$ in the regression. By default it's 0.001.
 \item $LibSVMRegression-NumberOfFolds$ : the number of folds for the cross validation. By default it's 3.
 \item $LibSVM-Shrinking$ : a boolean. We can use this to to eliminate outlying vectors. By default it's False. 
\end{itemize}

If we want to change the value , we must use the method $ResourceMap.Set(key,value)$. If we want to retrieve the value , we must use the method $ResourceMap.Get(key)$.













